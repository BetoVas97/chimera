

using System;
using System.Text;
using System.Collections.Generic;

namespace Chimera {

    class CILGenerator {

        SymbolTable symbolTable;
        ProcedureTable procedureTable;
        bool inProcedure;
        int labelCounter = 0;
        string currentProcedureName;
        Stack<string> cycles;
        string ifElseIfFinalLabel;

        //-----------------------------------------------------------
        string GenerateLabel() {
            return String.Format("${0:000000}", labelCounter++);
        }

        //-----------------------------------------------------------
        static readonly IDictionary<Type, string> cilTypes =
            new Dictionary<Type, string>() {
                { Type.BOOL, "bool" },
                { Type.INT, "int32" },
                { Type.STRING, "string"},
                { Type.LIST_OF_STRING, "string"},
                { Type.LIST_OF_INT, "int32"},
                { Type.LIST_OF_BOOL, "bool"},
                { Type.VOID, "void"}
            };

        static readonly ISet<Type> CILListTypes =
    new HashSet<Type>() {
                Type.LIST_OF_STRING,
                Type.LIST_OF_INT,
                Type.LIST_OF_BOOL
            };

        public CILGenerator(SymbolTable table, ProcedureTable procedureTable) {
            this.symbolTable = table;
            this.procedureTable = procedureTable;
            inProcedure = false;
            currentProcedureName = "";
            ifElseIfFinalLabel = "";
            cycles = new Stack<string>();
        }

        public string Visit(Program node) {
            return "// Code generated by the chimera compiler.\n\n"
                + ".assembly 'chimera' {}\n\n"
                + ".assembly extern 'chimeralib' {}\n\n"
                + ".assembly extern System.Core{\n  .ver 4:0:0:0 \n .publickeytoken = (B7 7A 5C 56 19 34 E0 89 )\n}\n"
                + ".class public 'ChimeraProgram' extends "
                + "['mscorlib']'System'.'Object' {\n"
                //+ inicializacion()
                + setGlobalVariablesAndConst()
                + Visit((dynamic)node[2])
                + "\n\t.method public static void 'start'() {\n"
                + "\t\t.entrypoint\n"
                + Visit((dynamic)node[3])
                + "\t\tret\n"
                + "\t}\n"
                + "}\n";
        }

        //-----------------------------------------------------------
        public string Visit(ProcedureDeclarationList node) {
            return VisitChildren(node);
        }

            //-----------------------------------------------------------
            public string Visit(StatementList node) {
            return VisitChildren(node);
        }

        public string Visit(CallStatement node) {
            string procName = node.AnchorToken.Lexeme;
            string type = cilTypes[procedureTable[procName].returnedType];
            string parameters ="";
            string parametrosTypes="";

            foreach (var child in procedureTable[procName].parametersOrder) {
                parametrosTypes += cilTypes[child];
                parametrosTypes += ",";
            }

            foreach (var child in node) {
                parameters += Visit((dynamic)child);
                parameters += "\n";
            }

            parametrosTypes = parametrosTypes.ToLower();

            if (parameters.Length > 0) { // removing extra commas
                parameters = parameters.Substring(0, parameters.Length - 1);
                parametrosTypes = parametrosTypes.Substring(0, parametrosTypes.Length - 1);
            }

            if (procedureTable[procName].predefined == "P")
                return parameters +
                "\t\tcall " + type + " class ['chimeralib']'Chimera'."+ "'Utils'::'" + procName + "'("+ parametrosTypes+ ")\n";

            else
                return parameters +"\t\tcall " + type + " class ChimeraProgram::"+ procName + "("+ parametrosTypes+ ")\n";
        }

        public string Visit(Str_Literal node) {
            var strValue = Convert.ToString(node.AnchorToken.Lexeme);

            if (strValue.Contains("\"\"\""))
                strValue = strValue.Replace("\"\"\"", "\"");

            return "\t\tldstr \""
                    + strValue
                    + "\"\n";
        }

        /*
        public string inicializacion()
        {
            return "\n\t.method public hidebysig specialname rtspecialname" +
            " instance \n\t\tdefault void '.ctor' () cil managed{" +
            "\n\t\tldarg.0" +
            "\n\t\tcall instance void object::'.ctor'()" +
            "\n\t\tret"
            + "\n\t}\n";
        }
        */

        public string Visit(Loop node) {
            var label = GenerateLabel();
            var bodyLabel = GenerateLabel();
            cycles.Push("'" + bodyLabel + "'");
            string statementString = Visit((dynamic)node[0]);
            return $"\t'{label}':\n{statementString}\t\tbr '{label}'\n\t'{bodyLabel}':\n";
        }

        public string Visit(Exit node) {
            return "\t\tbr " + cycles.Pop() + "\n";
        }

        public string Visit(Return node)
        {
            try {
                Visit((dynamic)node[0]);
            }
            catch (Exception) {
                return "\t\tret\n";
            }
            return Visit((dynamic)node[0]) + "\t\tret\n";
        }

        public string Visit(If node) {
            var label = GenerateLabel();
            var elseString = Visit((dynamic)node[3]);
            var expString = Visit((dynamic) node[0]);
            var statementString = Visit((dynamic) node[1]);
            var elseIfString = Visit((dynamic) node[2]);
            return $"{expString}\t\tbrfalse '{label}'\n{statementString}\n\t\tbr {ifElseIfFinalLabel+elseIfString+elseString}\n\t'{label}':\n";
        }

        public string Visit(ElseIfList node) {
            return VisitChildren(node);
        }

        public string Visit(ElseIf node) {
            var label = GenerateLabel();
            var expString = Visit((dynamic) node[0]);
            var statementString = Visit((dynamic) node[1]);
            return $"{expString}\t\tbrfalse '{label}'\n{statementString}\t\t br {ifElseIfFinalLabel}\n\t'{label}':\n";
        }

        public string Visit(Else node) {
            var label = GenerateLabel();
            ifElseIfFinalLabel = label;
            try {
                return Visit((dynamic)node[0]) + "\n\t'" + label + "':\n";
            }
            catch (Exception) {
                return "\n\t'" + label + "':\n";
            }
            return "\n\t'" + label + "':\n";
        }


        //Globales Y CONSTANTES GLOBALES
        //-----------------------------------------------------------
        public string initializeLists() {
            string listsResult = "";

            foreach (var entry in symbolTable) {
                var variable = entry.Value;
                string type = cilTypes[variable.type];
                if (variable.type == Type.LIST_OF_STRING || variable.type == Type.LIST_OF_INT || variable.type == Type.LIST_OF_BOOL) {
                    listsResult += "\t\t.locals init ( class [mscorlib]System.Collections.Generic.List`1<" + type + "> " + entry.Key + ")\n"
                    +"\t\tnewobj instance void class [mscorlib]System.Collections.Generic.List`1<" + type + ">::'.ctor'()\n" + "\t\tstloc " + entry.Key + "\n";
                    if (variable.type == Type.LIST_OF_STRING) {
                        foreach (var valor in variable.valueList) {
                            listsResult += "\t\tldloc " + entry.Key + "\n" + "\t\tldstr " + valor + "\n\t\tcallvirt instance void class [mscorlib]System.Collections.Generic.List`1<" + type + ">::Add(!0)\n";
                        }
                    }
                    listsResult += "\t\tldloc " + entry.Key + "\n\t\tstsfld class [mscorlib]System.Collections.Generic.List`1<" + type + "> ChimeraProgram::" + entry.Key + "\n";
                }
            }
            return listsResult;
        }

        public string setGlobalVariablesAndConst() {
            string resultDeclare = "";
            string resultInitialize = ".method private static hidebysig specialname rtspecialname \n           " +
                "default void '.cctor' ()  cil managed " +
                "{\n";
            string listsDeclaration = initializeLists();
            resultInitialize += listsDeclaration;

            foreach (var cell in symbolTable) {
                var variable = cell.Value;
                string type = cilTypes[variable.type];
                if (variable.type == Type.INT || variable.type == Type.BOOL || variable.type == Type.STRING) {
                    resultDeclare += "\t\t.field private static " + type + " " + cell.Key + "\n";
                } else {
                    resultDeclare += "\t\t.field private static class [mscorlib]System.Collections.Generic.List`1<" + type + "> " + cell.Key + "\n";
                }
                if (variable.type == Type.INT) {
                    if (variable.kind == "VAR")
                        resultInitialize += "\t\tldc.i4.0\n";

                    else if (variable.kind == "CONST")
                        resultInitialize += "\t\tldc.i4 " + variable.value + "\n";

                    resultInitialize += "\t\tstsfld " + type + " ChimeraProgram::" + cell.Key + "\n";
                }

                if (variable.type == Type.BOOL) {
                    if (variable.kind == "VAR")
                        resultInitialize += "\t\tldc.i4.0\n";

                    else if (variable.kind == "CONST") {
                        resultInitialize += "\t\tldc.i4.";
                        if (variable.value == true)
                            resultInitialize += 1 + "\n";
                        else
                            resultInitialize += 0 + "\n";
                    }
                    resultInitialize += "\t\tstsfld " + type + " ChimeraProgram::" + cell.Key + "\n";
                }

                if (variable.type == Type.STRING) {
                    if (variable.kind == "VAR")
                        resultInitialize += "\t\tldstr " + '"' + '"' + "\n";
                    else if (variable.kind == "CONST")
                        resultInitialize += "\t\tldstr " + variable.value + "\n";

                    resultInitialize += "\t\tstsfld " + type + " ChimeraProgram::" + cell.Key + "\n";
                }
            }
            return resultDeclare + "\n" + resultInitialize + "\t\tret\n\t}\n";
        }

        //PROCEDIMIENTOS
        
        public string Visit(ProcedureDeclaration node) {
            string procedureName = node[0].AnchorToken.Lexeme;
            var procedure = procedureTable[procedureName];
            string content = "";
            var listOfTypes = procedure.parametersOrder.ToArray();
            var listOfNames = procedure.parametersNamesOrder.ToArray();
            string parameters = "";

            for (int i = 0; i < listOfTypes.Length; i++) {
                parameters += cilTypes[listOfTypes[i]] + " " + listOfNames[i];
                parameters += ",";
            }

            if (parameters.Length > 0)
                parameters = parameters.Substring(0, parameters.Length - 1);

            string inicializar = ".method public static hidebysig" +
               "\tdefault ";

            inicializar += cilTypes[procedure.returnedType] + " " + procedureName;
            inicializar += "(" + parameters + ")";

            content += inicializar + " cil managed {\n";
            content += defineLocalVariables(procedure);

            currentProcedureName = procedureName;
            inProcedure = true;

            content += Visit((dynamic)node[5]);

            inProcedure = false;

            return "\t" + content + "\t\tret\n\t}\n";
        }

        public string defineLocalVariables(Procedures entry)
        {
            string result = "";
            foreach (var temp in entry.localSymbolTable) {
                var variable = temp.Value;
                string type = cilTypes[variable.type];
                if (variable.kind != "PARAM") {
                    if ((variable.type == Type.INT || variable.type == Type.BOOL || variable.type == Type.STRING))
                        result += "\t\t.locals init(" + type + " '" + temp.Key + "')\n";
                    if (variable.type == Type.INT) {
                        if (variable.kind == "VAR")
                            result += "\t\tldc.i4.0\n";

                        else if (variable.kind == "CONST")
                            result += "\t\tldc.i4 " + variable.value + "\n";

                        result += "\t\tstloc '" + temp.Key + "'\n";
                    }
                    if (variable.type == Type.BOOL) {
                        if (variable.kind == "VAR")
                            result += "\t\tldc.i4.0\n";

                        else if (variable.kind == "CONST") {
                            int valor;

                            if (variable.value == true)
                                valor = 1;

                            else
                                valor = 0;

                            result += "\t\tldc.i4." + valor + "\n";
                        }

                        result += "\t\tstloc '" + temp.Key + "'\n";
                    }

                    if (variable.type == Type.STRING) {
                        if (variable.kind == "VAR")
                            result += "\t\tldstr " + '"' + "\"\n";

                        else if (variable.kind == "CONST")
                            result += "\t\tldstr " + variable.value;

                        result += "\t\tstloc '" + temp.Key + "'\n";
                    }
                }
            }
            return result;
        }

        

        public string Visit(For node) {
            string type;
            StringBuilder stringBuilder = new StringBuilder();
            var identifier = node[0].AnchorToken.Lexeme;
            var label = GenerateLabel();
            var labelFor = GenerateLabel();
            var finalLabel = GenerateLabel();
            cycles.Push("'"+finalLabel+"'");
            type = (inProcedure && procedureTable[currentProcedureName].localSymbolTable.Contains(identifier))?
                cilTypes[procedureTable[currentProcedureName].localSymbolTable[identifier].type]:
                cilTypes[symbolTable[identifier].type];
            stringBuilder.AppendLine("\t\t.locals init ( "+ type + " $indice_temp,\n");
            stringBuilder.AppendLine("\t\tvaluetype[mscorlib]System.Collections.Generic.List`1 / Enumerator<"+type+">    $enumerator)\n");
            stringBuilder.AppendLine(Visit((dynamic)node[1]));
            stringBuilder.AppendLine("\t\tcallvirt instance valuetype [mscorlib]System.Collections.Generic.List`1Enumerator<!0> " );
            stringBuilder.AppendLine("\t\tclass [mscorlib]System.Collections.Generic.List`1<"+type+">::GetEnumerator()\n" );
            stringBuilder.AppendLine("\t\tstloc $enumerator\n");
            stringBuilder.AppendLine("\t.try {\n" );
            stringBuilder.AppendLine("\t\t br " + label+"\n");
            stringBuilder.AppendLine("\t'"+labelFor+"':\n");
            stringBuilder.AppendLine("\t\tldloca $enumerator\n");
            stringBuilder.AppendLine("\t\tcall instance !0 valuetype[mscorlib]System.Collections.Generic.List`1 / Enumerator<"+type+">::get_Current()\n");
            stringBuilder.AppendLine("\t\tstloc $indice_temp\n");
            stringBuilder.AppendLine("\t\tldloc $indice_temp\n" );
            stringBuilder.AppendLine(assign(node[0]));
            stringBuilder.AppendLine(Visit((dynamic)node[2]));
            stringBuilder.AppendLine("\t'" +label+"':\n");
            stringBuilder.AppendLine("\t\tldloca $enumerator\n");
            stringBuilder.AppendLine("\t\tcall instance bool valuetype[mscorlib]System.Collections.Generic.List`1 / Enumerator<"+type+">::MoveNext()\n");
            stringBuilder.AppendLine("\t\tbrtrue "+labelFor+"\n");
            stringBuilder.AppendLine("\t\tleave "+finalLabel+"\n\t}\n");
            stringBuilder.AppendLine("\tfinally{\n");
            stringBuilder.AppendLine("\t\tldloca $enumerator\n" );
            stringBuilder.AppendLine("\t\tconstrained. valuetype[mscorlib]System.Collections.Generic.List`1 / Enumerator<" + type+">\n");
            stringBuilder.AppendLine("\t\tcallvirt instance void class [mscorlib]System.IDisposable::Dispose()\n");
            stringBuilder.AppendLine("\t\tendfinally\n\t}\n");
            stringBuilder.AppendLine("\t'"+finalLabel+"':\n");
            return stringBuilder.ToString();
        }

        public string assign(Node node) {
            var identifier = node.AnchorToken.Lexeme;
            if (inProcedure && procedureTable[currentProcedureName].localSymbolTable.Contains(identifier)) {
                var localTable = procedureTable[currentProcedureName].localSymbolTable;
                string result = (localTable[identifier].kind == "PARAM")?  "\t\tstarg " + procedureTable[currentProcedureName].parametersNamesOrder.IndexOf(identifier) + "\n": "\t\tstloc '"+ identifier+ "'\n";
                return result;
            } else if (!inProcedure || !procedureTable[currentProcedureName].localSymbolTable.Contains(identifier)) {
                return "\t\tstsfld "+ cilTypes[symbolTable[identifier].type]+ " ChimeraProgram::" + identifier+ "\n";
            } else {
                return null;
            }
        }

        public string Visit(ListAssignmentS node) {
            var nombre = node.AnchorToken.Lexeme;
            Type type;
            if (inProcedure && procedureTable[currentProcedureName].localSymbolTable.Contains(nombre))
                type = procedureTable[currentProcedureName].localSymbolTable[nombre].type;

            else
                type = symbolTable[nombre].type;

            return Visit((dynamic)node[2]) +
                Visit((dynamic)node[0]) +
                Visit((dynamic)node[1])+
                "\t\tcallvirt instance void class [mscorlib] System.Collections.Generic.List`1<"+type+">::Insert(int32, !0)\n"+
                Visit((dynamic)node[2])+
                Visit((dynamic)node[0]) +
                "\t\tcallvirt instance void class [mscorlib] System.Collections.Generic.List`1<"+type+">::RemoveAt(int32)\n";
        }

        public string Visit(ListIndex node) {
            return Visit((dynamic)node[0]);
        }

        public string Visit(ListItem node)
        {
            var nombre = node[0].AnchorToken.Lexeme;
            Type tipo;
            if (inProcedure && procedureTable[currentProcedureName].localSymbolTable.Contains(nombre))
                tipo = procedureTable[currentProcedureName].localSymbolTable[nombre].type;

            else
                tipo = symbolTable[nombre].type;

            return //"\t.try{\n\t\t" +
            Visit((dynamic)node[0]) +
            Visit((dynamic)node[1]) +
            "\t\tcall !!0 class [System.Core]System.Linq.Enumerable::ElementAt<" + cilTypes[tipo] +
            ">(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>, int32)\n" //+
            /*"\t\tpop\n" +
            "\t\tleave '" + label + "' \n}\n\tcatch class [mscorlib]System.Exception {\n" +
            "\t\tpop\n" +
            "ldstr " + '"' + "Wrong index: [" + '"' + "\n" +
            Visit((dynamic)node[1]) +
            "\t\tbox [mscorlib]System.Int32\n" +
            "\t\tldstr " + '"' + "]" + '"' + "\n" +
            "\t\tcall string string::Concat(object, object, object)\n" +
            "\t\tnewobj instance void class [mscorlib]System.ArgumentOutOfRangeException::'.ctor'(string)\n" +
            "\t\tthrow\n\t}\n"+
            "\t'"+label+"':\n"*/;
        }

    public string Visit(Assignment node) {
            var targetIdentifier = node.AnchorToken.Lexeme;

            if (inProcedure && procedureTable[currentProcedureName].localSymbolTable.Contains(targetIdentifier)) {
                var tabla_local = procedureTable[currentProcedureName].localSymbolTable;
                if (tabla_local[targetIdentifier].kind == "PARAM") {
                    if (tabla_local[targetIdentifier].type == Type.LIST_OF_BOOL || tabla_local[targetIdentifier].type == Type.LIST_OF_INT || tabla_local[targetIdentifier].type == Type.LIST_OF_STRING) {
                        var type = cilTypes[procedureTable[currentProcedureName].localSymbolTable[targetIdentifier].type];
                        string listAssignment = "\t\t.locals init( class [mscorlib] System.Collections.Generic.List`1<" + type + ">" + targetIdentifier + ")\n\t\tnewobj instance void class [mscorlib]System.Collections.Generic.List`1<" + type + ">::'.ctor'()\n\t\tstloc " + targetIdentifier + "\n";
                        foreach (var value in node[0]) {
                            listAssignment += "\t\tldloc " + targetIdentifier + "\n"
                            + "\t\t"+Visit((dynamic) value) + "\n"
                            + "\t\tcallvirt instance void class [mscorlib]System.Collections.Generic.List`1<" + type + ">::Add(!0)\n";
                        }
                        listAssignment += "\t\tldloc " + targetIdentifier + "\n"
                        + "\t\tstarg " + (procedureTable[currentProcedureName].parametersNamesOrder.IndexOf(node.AnchorToken.Lexeme) + 1) + "\n";

                        return listAssignment;
                    } else {
                        return Visit((dynamic)node[0]) + "\t\tstarg " + procedureTable[currentProcedureName].parametersNamesOrder.IndexOf(node.AnchorToken.Lexeme) + "\n";
                    }
                } else{
                    return Visit((dynamic)node[0]) + "\t\tstloc '" + node.AnchorToken.Lexeme + "'\n";
                }
            } else if (!inProcedure || !procedureTable[currentProcedureName].localSymbolTable.Contains(targetIdentifier)) {
                if (symbolTable[targetIdentifier].type == Type.LIST_OF_BOOL || symbolTable[targetIdentifier].type == Type.LIST_OF_INT || symbolTable[targetIdentifier].type == Type.LIST_OF_STRING) {
                    var type = cilTypes[symbolTable[targetIdentifier].type];
                    string listAssignment = "\t\t.locals init( class [mscorlib] System.Collections.Generic.List`1<" + type + ">" + targetIdentifier + ")\n"
                    + "\t\tnewobj instance void class [mscorlib]System.Collections.Generic.List`1<" + type + ">::'.ctor'()\n"
                    + "\t\tstloc " + targetIdentifier + "\n";
                    foreach (var value in node[0]) {
                        listAssignment += "\t\tldloc " + targetIdentifier + "\n"
                        + Visit((dynamic)value) + "\n"
                        + "\t\tcallvirt instance void class [mscorlib]System.Collections.Generic.List`1<" + type + ">::Add(!0)\n";
                    }
                    listAssignment += "\t\tldloc " + targetIdentifier + "\n"
                    + "\t\tstsfld class [mscorlib] System.Collections.Generic.List`1<" + type + "> ChimeraProgram::" + targetIdentifier+"\n";
                    return listAssignment;
                } else {
                    return Visit((dynamic)node[0]) + "\t\tstsfld " + cilTypes[symbolTable[node.AnchorToken.Lexeme].type] + " ChimeraProgram::" + node.AnchorToken.Lexeme + "\n";
                }
            } else {
                return null;
            }
        }

        public string Visit(Call node)
        {
            string nombre = node.AnchorToken.Lexeme;
            string type = cilTypes[procedureTable[nombre].returnedType];
            string parametros = "";
            string parametrosTypes = "";

            foreach (var child in procedureTable[nombre].parametersOrder)
            {
                parametrosTypes += cilTypes[child];
                parametrosTypes += ",";
            }

            foreach (var child in node)
            {
                parametros += Visit((dynamic)child);
                parametros += "\n";
            }

            parametrosTypes = parametrosTypes.ToLower();

            if (parametros.Length > 0)
            {
                parametros = parametros.Substring(0, parametros.Length - 1);
                parametrosTypes = parametrosTypes.Substring(0, parametrosTypes.Length - 1);
            }

            if (procedureTable[nombre].predefined == "P")
                return parametros +
                "\t\tcall " + type + " class ['chimeralib']'Chimera'."+ "'Utils'::'" + nombre + "'("+ parametrosTypes+ ")\n";

            else
                return parametros +"\t\tcall " + type + " class ChimeraProgram::"+ nombre + "("+ parametrosTypes+ ")\n";
        }


        //NODOS FINALES - LITERALES
        //-----------------------------------------------------------

        public string Visit(Int_Literal node){
            var intValue = Convert.ToInt32(node.AnchorToken.Lexeme);

            string result = "";
            if (intValue <= 8) {
                result+= "\t\tldc.i4." + intValue + "\n";
            } else if (intValue <= 127) {
                result+= "\t\tldc.i4.s " + intValue + "\n";
            } else{
                result+= "\t\tldc.i4 " + intValue + "\n";
            }

            return result;
        }

        //-----------------------------------------------------------
        public string Visit(True node)
        {
            return "\t\tldc.i4.1\n";
        }

        //-----------------------------------------------------------
        public string Visit(False node)
        {
            return "\t\tldc.i4.0\n";
        }

        //NODOS NO CLASIFICADOS
        //-----------------------------------------------------------
        public string Visit(Identifier node) {
            var identifier = node.AnchorToken.Lexeme;
            if (inProcedure && procedureTable[currentProcedureName].localSymbolTable.Contains(identifier)) {
                if (procedureTable[currentProcedureName].localSymbolTable[identifier].kind == "PARAM") {
                    return "\t\tldarg " + procedureTable[currentProcedureName].parametersNamesOrder.IndexOf(identifier) + "\n";
                } else {
                    return "\t\tldloc '" + identifier + "'\n";
                }
            }
            else if (!inProcedure || !procedureTable[currentProcedureName].localSymbolTable.Contains(node.AnchorToken.Lexeme)) {
                string result = "\t\tldsfld ";
                if (symbolTable[identifier].type == Type.LIST_OF_BOOL || symbolTable[identifier].type == Type.LIST_OF_INT || symbolTable[identifier].type == Type.LIST_OF_STRING) {
                    result += "class[mscorlib]System.Collections.Generic.List`1 <" + cilTypes[symbolTable[identifier].type] + "> ChimeraProgram::" + identifier + "\n";
                } else {
                    result += cilTypes[symbolTable[identifier].type] + " ChimeraProgram::" + identifier + "\n";
                }
                return result;
            } else {
                return null;
            }
        }

        //OPERACIONES
        //-----------------------------------------------------------
        public string Visit(Not node) {
            return Visit((dynamic) node[0])
                + "\t\tnot\n";
        }

        public string Visit(Rem node) {
            return VisitBinaryOperator("rem", node);
        }

        public string Visit(Div node)
        {
            return VisitBinaryOperator("div", node);
        }

        public string Visit(Mult node)
        {
            return VisitBinaryOperator("mul", node);
        }

        public string Visit(Negation node)
        {
            try
            {
                Visit((dynamic)node[1]);
            }
            catch (ArgumentOutOfRangeException)
            {
                return Visit((dynamic)node[0])
                + "\t\tneg\n";
            }

            return VisitBinaryOperator("sub", node);
        }

        public string Visit(Sum node)
        {
            return VisitBinaryOperator("add", node);
        }

        public string Visit(MoreEqualOperator node)
        {
            return VisitBinaryOperator("cgt", node) + 
            VisitBinaryOperator("ceq",node) +
                "\t\tor\n";
        }

        public string Visit(LessEqualOperator node)
        {
            return VisitBinaryOperator("clt", node) +
            VisitBinaryOperator("ceq", node) +
                "\t\tor\n";
        }

        public string Visit(MoreOperator node)
        {
            return VisitBinaryOperator("cgt", node);
        }

        public string Visit(LessOperator node)
        {
            return VisitBinaryOperator("clt", node);
        }

        public string Visit(Inequality node)
        {
            return VisitBinaryOperator("ceq", node) + "\t\tldc.i4.1\n" + "\t\txor\n";
        }

        public string Visit(Equality node)
        {
            return VisitBinaryOperator("ceq", node);
        }

        public string Visit(And node)
        {
            return VisitBinaryOperator("and", node);
        }

        public string Visit(Or node)
        {
            return VisitBinaryOperator("or", node);
        }

        public string Visit(Xor node)
        {
            return VisitBinaryOperator("xor", node);
        }
       
        

        //-----------------------------------------------------------
        string VisitBinaryOperator(string op, Node node) {
            return Visit((dynamic) node[0])
                + Visit((dynamic) node[1])
                + "\t\t"
                + op 
                + "\n";            
        } 
        
        //-----------------------------------------------------------
        string VisitChildren(Node node) {
            var sb = new StringBuilder();
            foreach (var n in node) {
                sb.Append(Visit((dynamic) n));
            }
            return sb.ToString();
        }
    }
}
