using System;
using System.Text;
using System.Collections.Generic;
using System.Linq;

namespace Chimera {
    class CILGenerator {
        SymbolTable symbolTable;
        ProcedureTable procedureTable;
        int labelCounter = 0;

        private string currentScope = "";
        private int id = 0;
        private int currentId = 0;
        private int currentIfId = 0;
        private int currentElseCount = 0;

        //-----------------------------------------------------------
        string GenerateLabel() {
            return String.Format("${0:000000}", labelCounter++);
        }
        //-----------------------------------------------------------
        public CILGenerator(SymbolTable symbolTable, ProcedureTable procedureTable) {
            this.symbolTable = symbolTable;
            this.procedureTable = procedureTable;
        }
        //-----------------------------------------------------------
        //visits
        public void Visit(Program node){
            builder.AppendLine("// Code generated by the chimera compiler\n");
            builder.AppendLine(".assembly 'Chimera' {}");
            builder.AppendLine(".assembly extern 'ChimeraLib' {}");
            builder.AppendLine(".class public 'ChimeraProgram' extends ['mscorlib']'System'.'Object' {");
            builder.AppendLine();
            builder.AppendLine(DeclareVariablesOnScope(""));

            Visit((dynamic)node[node.Count() - 2]);

            builder.AppendLine("\t.method public static void main(){");
            builder.AppendLine("\t\t.entrypoint");
            builder.AppendLine();
            builder.AppendLine(InitializeVariablesOnScope(""));
            Visit((dynamic)node.Last());
            builder.AppendLine("\t\tret");
            builder.AppendLine("\t}");
            builder.AppendLine("}");
            return;
        }
        public void Visit(ProcedureDeclarationList node){
            VisitChildren(node);
        }
        public void Visit(DeclarationList node){
            //falta
        }
        public void Visit(ConstantDeclarationList node){
            //Do nothing
        }
        public void Visit(ConstantDeclaration node){
            //Do nothing
        }
        public void Visit(ParameterDeclarationList node){
            //falta
        }
        public void Visit(VariableDeclarationList node){
            //falta
        }
        public void Visit(VariableDeclaration node){
            //Do nothing
        }
        public void Visit(VariableDeclarationItems node){
            //falta
        }
        public void Visit(ProcedureDeclaration node){
            var procedureName = node.AnchorToken.Lexeme;
            var procedure = procedureTable[procedureName];
            Type type = procedure.type;
            string returnType = type.ToCilType();
            var lastScope = currentScope;
            currentScope = procedureName;

            builder.Append($"\t.method public static {returnType} '{procedureName}'(");
            builder.Append(DeclareParameters(procedureName));

            builder.AppendLine("){");
            builder.AppendLine(DeclareVariablesOnScope(procedureName));
            builder.AppendLine(InitializeVariablesOnScope(currentScope));

            if (node.Last() is StatementList)
            {
                Visit((dynamic)node.Last());
            }

            builder.AppendLine("\t\tret");
            builder.AppendLine("\t}");

            currentScope = lastScope;
        }
        
        public void Visit(StatementList node){
            VisitChildren(node);
        }
        public void Visit(Statement node){
            //falta
        }
        public void Visit(Equality node){
            VisitChildren(node);
            builder.AppendLine("\t\tceq");
        }
        public void Visit(Inequality node){
            VisitChildren(node);
            builder.AppendLine("\t\tceq");
            builder.AppendLine("\t\tldc.i4.1");
            builder.AppendLine("\t\txor");
        }
        public void Visit(LessOperator node){
            VisitChildren(node);
            builder.AppendLine("\t\tclt");
        }
        public void Visit(MoreOperator node){
            VisitChildren(node);
            builder.AppendLine("\t\tcgt");
        }
        public void Visit(LessEqualOperator node){
            VisitChildren(node);
            builder.AppendLine("\t\tcgt");
            builder.AppendLine("\t\tldc.i4.1");
            builder.AppendLine("\t\txor");
        }
        public void Visit(MoreEqualOperator node){
            VisitChildren(node);
            builder.AppendLine("\t\tclt");
            builder.AppendLine("\t\tldc.i4.1");
            builder.AppendLine("\t\txor");
        }
        public void Visit(Sum node){
            VisitChildren(node);
            builder.AppendLine("\t\tadd.ovf");
        }
        public void Visit(Minus node){
            VisitChildren(node);
            builder.AppendLine("\t\tsub.ovf");
        }
        public void Visit(Negation node){
            VisitChildren(node);
            builder.AppendLine("\t\tadd.ovf");
        }
        public void Visit(Div node){
            VisitChildren(node);
            builder.AppendLine("\t\tdiv");
        }
        public void Visit(Rem node){
            VisitChildren(node);
            builder.AppendLine("\t\trem");
        }
        public void Visit(Not node){
            Visit((dynamic)node[0]);
            builder.AppendLine("\t\tldc.i4.1");
            builder.AppendLine("\t\txor");
        }
        public void Visit(Mult node){
            VisitChildren(node);
            builder.AppendLine("\t\tmul.ovf");
        }
        public void Visit(And node){
            VisitChildren(node);
            builder.AppendLine("\t\tand");
        }
        public void Visit(Or node){
            VisitChildren(node);
            builder.AppendLine("\t\tor");
        }
        public void Visit(TypeNode node){
            //falta
        }
        public void Visit(List node){
            Visit((dynamic)Node.fromToken(node.AnchorToken));
            builder.Append("[]");
        }
        public void Visit(If node){
            currentIfId = id++;
            int previousElseCount = currentElseCount;
            currentElseCount = 0;

            builder.AppendLine();
            builder.AppendLine($"\tIf_{currentIfId}_0_condition:");
            Visit((dynamic)node[0]);
            builder.AppendLine($"\t\tbrzero If_{currentIfId}_1_condition");

            builder.AppendLine($"\tIf_{currentIfId}_0_body:");
            Visit((dynamic)node[1]);
            builder.AppendLine($"\t\tbr If_{currentIfId}_End");
            builder.AppendLine();

            VisitChildren(node, 2);
            builder.AppendLine($"\tIf_{currentIfId}_{currentElseCount + 1}_condition:");
            builder.AppendLine($"\tIf_{currentIfId}_End:");

            currentElseCount = previousElseCount;
        }
        public void Visit(Else node){
            currentElseCount++;
            builder.AppendLine($"\tIf_{currentIfId}_{currentElseCount}_condition:");
            VisitChildren(node);
            builder.AppendLine($"\t\tbr If_{currentIfId}_End");
            builder.AppendLine();
        }
        public void Visit(ElseIf node){
            currentElseCount++;

            builder.AppendLine($"\tIf_{currentIfId}_{currentElseCount}_condition:");
            Visit((dynamic)node[0]);
            builder.AppendLine($"\t\tbrzero If_{currentIfId}_{currentElseCount + 1}_condition");
            builder.AppendLine();

            builder.AppendLine($"\tIf_{currentIfId}_{currentElseCount}_body:");
            VisitChildren(node, 1);
            builder.AppendLine($"\t\tbr If_{currentIfId}_End");
            builder.AppendLine();
        }
        public void Visit(ElseIfList node){
            VisitChildren(node);
        }
        public void Visit(Assignment node){
            Node first = node[0];
            if (first is ListIndex)
            {
                (first as ListIndex).isAssignment = true;
            }
            else if (first is Identifier)
            {
                (first as Identifier).isAssignment = true;
            }
            Visit((dynamic)node[0]);
            Visit((dynamic)node[1]);
            if (node[0] is ListIndex)
            {
                Type type = node[0].extra;
                switch (type)
                {
                    case Type.BOOL_LIST:
                    case Type.INT_LIST:
                        builder.AppendLine("\t\tstelem.i4");
                        break;
                    case Type.STRING_LIST:
                        builder.AppendLine("\t\tstelem.ref");
                        break;
                }
            }
            else
            {
                string varName = node[0].AnchorToken.Lexeme;
                StoreInVariable(varName);
            }
        }
        public void Visit(CallStatement node){
            VerifyCall(node);
            var procedureName = node.AnchorToken.Lexeme;
            Type type = procedureTable[procedureName].type;
            if (type != Type.VOID)
            {
                builder.AppendLine("\t\tpop");
            }
        }
        public void Visit(Loop node){
            var lastId = currentId;
            currentId = id++;
            builder.AppendLine($"\tloop_{currentId}:");
            VisitChildren(node);
            builder.AppendLine($"\t\tbr loop_{currentId}");
            builder.AppendLine($"\tend_{currentId}:");

            currentId = lastId;
        }
        public void Visit(For node){
            var lastId = currentId;
            currentId = id++;

            string varName = node[0].AnchorToken.Lexeme;
            string indexVarName = $"__{varName}_index";
            builder.AppendLine("\t\tldc.i4.0");
            StoreInVariable(indexVarName);

            Visit((dynamic)node[1]);
            builder.AppendLine($"\tfor_{currentId}:");
            builder.AppendLine($"\t\tdup");
            LoadVariable(indexVarName);
            switch (GetSymbol(varName).type)
            {
                case Type.BOOL:
                case Type.INT:
                    builder.AppendLine($"\t\tldelem.i4");
                    break;
                default:
                    builder.AppendLine($"\t\tldelem.ref");
                    break;

            }
            StoreInVariable(varName);

            builder.AppendLine();
            Visit((dynamic)node[2]);

            builder.AppendLine();
            LoadVariable(indexVarName);
            builder.AppendLine("\t\tldc.i4.1");
            builder.AppendLine("\t\tadd");
            StoreInVariable(indexVarName);

            builder.AppendLine($"\tnext_{currentId}:");
            builder.AppendLine($"\t\tdup");
            builder.AppendLine($"\t\tldlen");
            builder.AppendLine($"\t\tconv.i4");
            LoadVariable(indexVarName);
            builder.AppendLine($"\t\tbgt for_{currentId}");

            builder.AppendLine($"\tend_{currentId}:");
            builder.AppendLine($"\t\tpop");

            currentId = lastId;
        }
        public void Visit(Return node){
            bool returnsSomething = node.Count() != 0;
            string procedureName = currentScope;
            Type returnType = procedureTable[procedureName].type;

            if (returnsSomething)
            {
                Visit((dynamic)node[0]);
            }
            else
            {
                string defaultValue = GetTypeDefaultCilValue(returnType);
                builder.AppendLine($"\t\t{defaultValue}");
            }
            builder.AppendLine("\t\tret");
        }
        public void Visit(Exit node){
            builder.AppendLine($"\t\tbr end_{currentId}");
        }
        public void Visit(AssignmentType node){
            //falta
        }
        public void Visit(ListIndex node){
            Visit((dynamic)node[0]);
            Visit((dynamic)node[1]);
            Type type = node.extra;
            if (!node.isAssignment)
            {
                switch (type)
                {
                    case Type.BOOL_LIST:
                    case Type.INT_LIST:
                        builder.AppendLine("\t\tldelem.i4");
                        break;
                    case Type.STRING_LIST:
                        builder.AppendLine("\t\tldelem.ref");
                        break;
                }
            }
        }
        public void Visit(ListItem node){
            //falta
        }
        public void Visit(ListIndexAssignment node){
            //falta
        }
        public void Visit(SimpleAssignment node){
            //falta
        }
        public void Visit(Identifier node){
            string varName = node.AnchorToken.Lexeme;
            if (!node.isAssignment)
            {
                LoadVariable(varName);
            }
        }
        public void Visit(Call node){
            VerifyCall(node);
        }
        public void Visit(ListNode node){
            VisitChildren(node);
        }
        public void Visit(IntegerNode node){
            builder.AppendLine("int32");
        }
        public void Visit(StringNode node){
            builder.AppendLine("string");
        }
        public void Visit(BooleanNode node){
            builder.Append("bool");
        }
        public void Visit(Int_Literal node){
            builder.AppendLine($"\t\tldc.i4 {node.AnchorToken.Lexeme}");
        }
        public void Visit(Str_Literal node){
            builder.AppendLine($"\t\tldstr {EscapeString(node.AnchorToken.Lexeme)}");
        }
        public void Visit(False node){
            //falta
        }
        public void Visit(True node){
            //falta
        }

        private string DeclareParameters(string procedureName)
        {
            StringBuilder stringBuilder = new StringBuilder();
            var _params = GetParams(procedureName);
            var start = true;
            foreach (var param in _params)
            {
                if (!start)
                {
                    stringBuilder.Append(", ");
                }
                start = false;
                stringBuilder.Append(DeclareLocalVar(param));
            }
            return stringBuilder.ToString();
        }
        private string DeclareVariablesOnScope(string scope){
            var locals = GetLocals(scope);
            var start = true;
            StringBuilder stringBuilder = new StringBuilder();
            if (scope == "")
            {
                foreach (var global in locals)
                {
                    stringBuilder.AppendLine(DeclareGlobalVar(global));
                }
            }
            else
            {
                stringBuilder.Append("\t\t.locals init (");
                start = true;
                foreach (var local in locals)
                {
                    if (!start)
                    {
                        stringBuilder.Append(", ");
                    }
                    stringBuilder.AppendLine();
                    start = false;
                    stringBuilder.Append($"\t\t\t{DeclareLocalVar(local)}");
                }
                stringBuilder.AppendLine();
                stringBuilder.AppendLine("\t\t)");
            }
            return stringBuilder.ToString();
        }
        private string InitializeVariablesOnScope(string scope)
        {
            StringBuilder stringBuilder = new StringBuilder();
            var locals = GetLocals(scope);

            if (scope == "")
            {
                foreach (var global in locals)
                {
                    stringBuilder.Append(InitializeStaticVariable(global));
                }
            }
            else
            {
                foreach (var local in locals)
                {
                    stringBuilder.Append(InitializeLocalVariable(local));
                }
            }
            return stringBuilder.ToString();
        }

        private SymbolTable GetScopeSymbols(string scope)
        {
            if (scope == "")
            {
                return symbolTable;
            }
            else
            {
                return procedureTable[scope].symbols;
            }
        }
        //error-----
        private string DeclareGlobalVar(VariableType variable)
        {
            return $"\t.field public static {variable.Value.type.ToCilType()} '{variable.Key}'";
        }

        private string DeclareLocalVar(VariableType variable)
        {
            return $"{variable.Value.type.ToCilType()} {variable.Key}";
        }
        //error-----

        private string InitializeStaticVariable(VariableType variable)
        {
            StringBuilder stringBuilder = new StringBuilder();
            string value = GetCilValue(variable);
            stringBuilder.AppendLine($"\t\t{value}");
            stringBuilder.AppendLine($"\t\tstsfld {variable.Value.type.ToCilType()} class ['Chimera']'ChimeraProgram'::'{variable.Key}'");
            return stringBuilder.ToString();
        }
        private string InitializeLocalVariable(VariableType variable)
        {
            StringBuilder stringBuilder = new StringBuilder();
            string value = GetCilValue(variable);
            stringBuilder.AppendLine($"\t\t{value}");
            stringBuilder.AppendLine($"\t\tstloc '{variable.Key}'");
            return stringBuilder.ToString();
        }

        private string GetCilValue(VariableType variable){
            StringBuilder result = new StringBuilder();
            int index = 0;
            SymbolTable.Row row = variable.Value;
            switch (row.type)
            {
                case Type.BOOL:
                    var b = row.value ? 1 : 0;
                    return $"ldc.i4.{b}";
                case Type.INT:
                    return $"ldc.i4 {row.value}";
                case Type.STRING:
                    string s = row.value;
                    s = s.Count() == 0 ? "\"\"" : s;
                    return $"ldstr {s}";
                case Type.BOOL_LIST:
                    bool[] constBoolArr = row.value as bool[];
                    result.AppendLine($"ldc.i4 {constBoolArr.Length}");
                    result.AppendLine("\t\tnewarr int32");
                    foreach (bool val in constBoolArr)
                    {
                        result.AppendLine($"\t\tdup");
                        result.AppendLine($"\t\tldc.i4 {index++}");
                        result.AppendLine($"\t\tldc.i4.{(val ? 1 : 0)}");
                        result.AppendLine($"\t\tstelem.i4");
                    }
                    return result.ToString();
                case Type.INT_LIST:
                    int[] constIntArr = row.value as int[];
                    result.AppendLine($"ldc.i4 {constIntArr.Length}");
                    result.AppendLine("\t\tnewarr int32");
                    foreach (int val in constIntArr)
                    {
                        result.AppendLine($"\t\tdup");
                        result.AppendLine($"\t\tldc.i4 {index++}");
                        result.AppendLine($"\t\tldc.i4 {val}");
                        result.AppendLine($"\t\tstelem.i4");
                    }
                    return result.ToString();
                case Type.STRING_LIST:
                    string[] constStrArr = row.value as string[];
                    result.AppendLine($"ldc.i4 {constStrArr.Length}");
                    result.AppendLine("\t\tnewarr string");
                    foreach (string val in constStrArr)
                    {
                        result.AppendLine($"\t\tdup");
                        result.AppendLine($"\t\tldc.i4 {index++}");
                        result.AppendLine($"\t\tldstr {val}");
                        result.AppendLine($"\t\tstelem.ref");
                    }
                    return result.ToString();
                case Type.VOID:
                    return "";
            }
            throw new Exception($"Could not find value for: {variable.Key}");
        }

        void VisitChildren(Node node, int skip = 0, int take = 0)
        {
            skip = Math.Min(skip, node.Count());
            if (take == 0)
            {
                take = node.Count() - skip;
            }
            foreach (var n in node.Skip(skip).Take(take))
            {
                Visit((dynamic)n);
            }
        }
        private void LoadVariable(string varName){
            var symbol = GetSymbol(varName);
            if (symbol.kind == Kind.PARAM)
            {
                builder.AppendLine($"\t\tldarg {varName}");
            }
            else if (currentScope != "" && procedureTable[currentScope].symbols.Contains(varName))
            {
                builder.AppendLine($"\t\tldloc {varName}");
            }
            else
            {
                builder.AppendLine($"\t\tldsfld {symbol.type.ToCilType()} class ['Chimera']'ChimeraProgram'::'{varName}'");
            }
        }
        private void StoreInVariable(string varName)
        {
            var symbol = GetSymbol(varName);
            var varType = symbol.type.ToCilType();
            if (currentScope != "" && procedureTable[currentScope].symbols.Contains(varName))
            {
                if (symbol.kind == Kind.PARAM)
                {
                    builder.AppendLine($"\t\tstarg {varName}");
                }
                else
                {
                    builder.AppendLine($"\t\tstloc {varName}");
                }
            }
            else
            {
                builder.AppendLine($"\t\tstsfld {varType} class ['Chimera']'ChimeraProgram'::'{varName}'");
            }
        }
        private void VerifyCall(Node node)
        {
            string procedureName = node.AnchorToken.Lexeme;
            var procedure = procedureTable[procedureName];
            string returnType = procedure.type.ToCilType();
            string _prefix = "";

            if (procedure.isPredefined)
            {
                _prefix = "['ChimeraLib']'Chimera'.Lib";
            }
            else
            {
                _prefix = "['Chimera']'ChimeraProgram'";
            }

            VisitChildren(node);
            builder.Append($"\t\tcall {returnType} class {_prefix}::'{procedureName}'(");
            var _params = GetParams(procedureName);
            var start = true;
            foreach (var param in _params)
            {
                if (!start)
                {
                    builder.Append(",");
                }
                start = false;
                builder.Append($"{param.Value.type.ToCilType()}");
            }
            builder.AppendLine(")");
        }
        private string GetTypeDefaultCilValue(Type type)
        {
            switch (type)
            {
                case Type.BOOL:
                case Type.INT:
                    return "ldc.i4.0";
                case Type.STRING:
                    return "ldstr \"\"";
                case Type.BOOL_LIST:
                case Type.INT_LIST:
                    return "ldc.i4.0\nnewarr int32";
                case Type.STRING_LIST:
                    return "ldc.i4.0\nnewarr string";
                case Type.VOID:
                    return "";
            }
            throw new Exception($"Could not find CIL type for: {type}");
        }
        SymbolTable.Row GetSymbol(string key){
            // Try current scope first, then global
            if (currentScope.Length > 0 && procedureTable[currentScope].symbols.Contains(key))
            {
                return procedureTable[currentScope].symbols[key];
            }
            else if (symbolTable.Contains(key))
            {
                return symbolTable[key];
            }
            return null;
        }

        private IEnumerable<VariableType> GetLocals(string scope){
            SymbolTable table = GetScopeSymbols(scope);
            return table.Where(kv => kv.Value.kind != Kind.PARAM).OrderBy(kv => kv.Value.pos);
        }
        private IEnumerable<VariableType> GetParams(string scope){
            SymbolTable table = GetScopeSymbols(scope);
            return table.Where(kv => kv.Value.kind == Kind.PARAM).OrderBy(kv => kv.Value.pos);
        }
        string EscapeString(string s)
        {
            var tmp = s.Substring(1, s.Length - 2).Replace("\"\"", "\\\"");
            return $"\"{tmp}\"";
        }
    }
}